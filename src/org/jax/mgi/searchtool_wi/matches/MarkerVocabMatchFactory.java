package org.jax.mgi.searchtool_wi.matches;

// standard java classes
import java.util.*;
import java.io.IOException;

// lucene
import org.apache.lucene.search.Hit;

// QS shared classes
import QS_Commons.IndexConstants;

// MGI Shared Classes
import org.jax.mgi.shr.config.Configuration;
import org.jax.mgi.shr.timing.TimeStamper;


/**
* A MarkerVocabMatchFactory is responsible for MarkerVocabMatch object
* creation and data initialization
*/
public class MarkerVocabMatchFactory extends AbstractMatchFactory
{

  //-------------//
  // Constructor //
  //-------------//

  /**
  * Constructs the factory, calling the parent class constructor with config
  */
  public MarkerVocabMatchFactory(Configuration c)
  {
    super(c);
  }

  //------------------------------------//
  // Over-ridden Parent Abstract Method
  //------------------------------------//

  /**
  * Generates and initializes a MarkerVocabMatch
  */
  public MarkerVocabMatch getMatch(Hit h)
    throws IOException
  {
    // match type generated by this factory
    MarkerVocabMatch markerVocabMatch = new MarkerVocabMatch();

    // use parent class's implementation to fill basic information about match
    this.setHit(h);
    this.loadAbstractMatchInfo(markerVocabMatch);

    // fill data specific to this match type
    markerVocabMatch.setVocabulary( hit.get(IndexConstants.COL_OBJ_TYPE) );
    markerVocabMatch.setAncestorKey( hit.get(IndexConstants.COL_DB_KEY) );


    // try the other column it could be defined in...  I don't like this,
    // but it solves the problem.  Hope to get back here and find a
    // better solution - pf
    if ( markerVocabMatch.getVocabulary() == null )
    {
        markerVocabMatch.setVocabulary( hit.get(IndexConstants.COL_VOCABULARY) );
    }

    return markerVocabMatch;

  }

}

